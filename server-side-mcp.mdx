---
title: "Server-Side MCP"
description: "Expose your backend as an MCP server for Crow's agent"
---

Server-Side MCP lets Crow's agent call tools on **your** MCP server. You build an MCP server that wraps your backend, point Crow at it, and the agent automatically discovers and uses your tools.

<Info>
**MCP (Model Context Protocol)** is an open standard for connecting AI agents to external services. Instead of uploading an OpenAPI spec, you run a live MCP server that Crow connects to directly.
</Info>

## When to Use Server-Side MCP vs OpenAPI

| | OpenAPI | Server-Side MCP |
|--|---------|-----------------|
| **Setup** | Upload a spec file | Run a live server |
| **Tool discovery** | Parsed from spec (static) | Queried from server (live) |
| **Auth options** | API Key, Bearer, JWT Forward | Service Key + Header Mappings |
| **Best for** | Simple REST APIs | Complex logic, multi-step tools, real-time data |
| **Requires** | OpenAPI/Swagger spec | MCP server (e.g., FastMCP, custom) |

**Use OpenAPI** if you already have a spec and just need simple endpoint calls.

**Use Server-Side MCP** if you want richer tool definitions, server-side logic, or your API doesn't have a clean OpenAPI spec.

<Note>
Server-Side MCP and OpenAPI are **mutually exclusive** per product. Configuring one removes the other.
</Note>

---

## Setup

### 1. Build Your MCP Server

Create an MCP server that exposes your tools. Here's a minimal example using [FastMCP](https://github.com/jlowin/fastmcp):

<CodeGroup>

```python Python (FastMCP)
from fastmcp import FastMCP

mcp = FastMCP("My Backend")

@mcp.tool()
async def get_order(order_id: str) -> dict:
    """Look up an order by ID."""
    order = await db.orders.find(order_id)
    return {"id": order.id, "status": order.status, "total": order.total}

@mcp.tool()
async def cancel_order(order_id: str) -> dict:
    """Cancel a pending order."""
    result = await db.orders.cancel(order_id)
    return {"success": result.ok, "message": result.message}
```

```javascript Node.js (MCP SDK)
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";

const server = new McpServer({ name: "My Backend", version: "1.0.0" });

server.tool("get_order", { order_id: z.string() }, async ({ order_id }) => {
  const order = await db.orders.find(order_id);
  return { content: [{ type: "text", text: JSON.stringify(order) }] };
});
```

</CodeGroup>

Run it:

```bash
# Python (FastMCP)
pip install fastmcp
fastmcp run server.py --transport streamable-http --host 0.0.0.0 --port 8080

# Node.js
npx @modelcontextprotocol/server --transport streamable-http --port 8080
```

### 2. Connect in Dashboard

1. Go to **Integration** → **Server-Side MCP**
2. Fill in:

| Field | Description | Example |
|-------|-------------|---------|
| **Name** | Display name | `my-backend` |
| **URL** | Your MCP server endpoint | `https://mcp.yourapp.com/mcp` |
| **Transport** | Connection protocol | Streamable HTTP (recommended) |

3. Click **Test Connection** to verify Crow can reach your server and discover tools
4. Click **Save**
5. Go to **Actions** to enable the tools you want the agent to use

### 3. Set Up Authentication

Your MCP server likely needs to authenticate requests. See [Server-Side MCP Authentication](/server-side-mcp-authentication) for the full guide on:

- **Service Keys** — how Crow proves it's authorized to call your server
- **Identity Headers** — how end-user identity flows through to your tools

---

## How It Works

When an end user sends a message in the widget:

```
1. User sends message → Crow backend
2. Crow backend connects to your MCP server
   - Sends configured headers (service key, identity headers)
   - Discovers available tools
3. AI agent decides which tool to call based on user's message
4. Tool executes on your MCP server
5. Result flows back through Crow to the user
```

Crow connects to your MCP server **on every chat request** to ensure it always has the latest tool definitions.

---

## Header Mappings

Header mappings let you forward dynamic values — like the current user's ID or email — to your MCP server as HTTP headers.

| Source | What it reads | Example |
|--------|--------------|---------|
| `identity.*` | Claims from the user's identity token | `identity.user_id` → the logged-in user's ID |
| `product.*` | Fields from the product config | `product.id` → the Crow product ID |

**Example:** Your MCP server needs to know which user is asking. Add a header mapping:

```
Header: X-User-ID
Source: identity.user_id
```

Now every request from Crow to your MCP server includes `X-User-ID: user_456`.

See [Server-Side MCP Authentication](/server-side-mcp-authentication) for the full identity flow.

---

## Tips

- Use descriptive tool names and descriptions — the AI uses these to decide when to call each tool
- Return structured data (JSON objects) from tools, not raw strings
- Keep tools focused — one action per tool works better than multi-purpose tools
- Test in the **Sandbox** after connecting to verify the agent uses your tools correctly

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Connection failed | Verify URL is reachable, check transport type matches server |
| Tools not appearing | Click **Sync Tools** in dashboard, check server logs |
| Agent not using tools | Enable tools in **Actions**, check tool descriptions are clear |
| 401 / auth errors | See [Authentication guide](/server-side-mcp-authentication) |
| Timeout errors | Ensure MCP server responds within 10 seconds |

---

<Card title="Server-Side MCP Authentication" icon="key" href="/server-side-mcp-authentication">
  Service keys, identity headers, and the full auth chain explained
</Card>
