---
title: "Server-Side MCP Authentication"
description: "Service keys, identity headers, and how the full auth chain works"
---

This page explains exactly how authentication works when Crow calls your MCP server, and how your MCP server calls back to Crow's API. Every header, every token, every hop.

---

## The Auth Chain

There are **three hops** in the full chain. Here's what happens at each one:

```
┌─────────┐         ┌──────────────┐         ┌────────────┐         ┌──────────────┐
│  Widget  │───(1)──→│ Crow Backend │───(2)──→│ MCP Server │───(3)──→│ Crow Backend │
│ (browser)│         │              │         │  (yours)   │         │  (API routes)│
└─────────┘         └──────────────┘         └────────────┘         └──────────────┘
```

### Hop 1: Widget → Crow Backend

The widget sends the user's **identity token** (a JWT your backend minted) with every chat message.

| What | Value |
|------|-------|
| **Token** | Identity JWT (signed with your Crow verification secret) |
| **Sent as** | `identity_token` field in the chat request body |
| **Validated by** | Crow backend using your product's verification secret |
| **Purpose** | Proves who the end user is |

This is the standard [Identity Verification](/identity-verification) flow. If you haven't set it up, users are treated as anonymous and identity headers won't be available.

### Hop 2: Crow Backend → Your MCP Server

When Crow connects to your MCP server to execute tools, it sends **three types of headers**:

| Header | Source | Example Value |
|--------|--------|---------------|
| **X-Service-Key** | Auto-injected from your product's service key | `HCF8nVjR8Y...` |
| **Static headers** | Whatever you configured in the dashboard | `Authorization: Bearer sk-...` |
| **Identity headers** | Resolved from header mappings (see below) | `X-User-ID: user_456` |

**This is where your MCP server authenticates the request.** Check the `X-Service-Key` header to verify the request is coming from Crow, not a random caller.

### Hop 3: Your MCP Server → Crow Backend

When your MCP server needs to call Crow's API (e.g., to update a product setting, fetch data), it sends the **service key** back:

| What | Value |
|------|-------|
| **Header** | `X-Service-Key` |
| **Value** | Same service key from hop 2 (or from your server's env var) |
| **Validated by** | Crow backend's `verify_service_or_clerk` middleware |
| **Purpose** | Proves your MCP server is authorized to access this product's API |

---

## Service Keys

A service key is a shared secret between your Crow product and your MCP server. Crow sends it to your MCP server on every request. Your MCP server sends it back when calling Crow's API.

### Where to Find Your Service Key

1. Go to your product's **Settings** page in the dashboard
2. Copy the **Service Key** value

### How It Flows

```
Product settings (dashboard)
    │
    ▼
Stored in products table → service_key column
    │
    ▼
Crow backend reads it when building MCP connection
    │
    ▼
Sent as X-Service-Key header to your MCP server (Hop 2)
    │
    ▼
Your MCP server receives it, uses it to call Crow API (Hop 3)
    │
    ▼
Crow backend validates it against MCP_SERVICE_KEY env var
```

### Validating the Service Key on Your MCP Server

If your MCP server is **not** calling back to Crow's API (it just does its own thing), you should still validate the service key to make sure the request is coming from Crow:

<CodeGroup>

```python Python (FastMCP)
import hmac
import os
from fastmcp import FastMCP
from fastmcp.dependencies import Depends, CurrentHeaders

mcp = FastMCP("My Backend")
EXPECTED_KEY = os.environ["SERVICE_KEY"]

async def verify_crow_request(headers: dict = CurrentHeaders()):
    """Reject requests that aren't from Crow."""
    key = headers.get("x-service-key", "")
    if not hmac.compare_digest(key, EXPECTED_KEY):
        raise ValueError("Invalid service key")

@mcp.tool()
async def get_order(
    order_id: str,
    _auth = Depends(verify_crow_request),
) -> dict:
    # Only runs if service key is valid
    return await db.orders.find(order_id)
```

```javascript Node.js
function verifyCrowRequest(headers) {
  const key = headers["x-service-key"] || "";
  const expected = process.env.SERVICE_KEY;

  if (!expected || !timingSafeEqual(Buffer.from(key), Buffer.from(expected))) {
    throw new Error("Invalid service key");
  }
}
```

</CodeGroup>

<Warning>
Always use **constant-time comparison** (`hmac.compare_digest` in Python, `timingSafeEqual` in Node) to prevent timing attacks. Never use `==` to compare secrets.
</Warning>

### If Your MCP Server Calls Back to Crow's API

This is the pattern used by Crow's own dogfood MCP server. Your MCP server receives the service key from Crow, then includes it when making API calls back:

<CodeGroup>

```python Python (FastMCP + httpx)
import os
import httpx
from fastmcp import FastMCP
from fastmcp.dependencies import Depends, CurrentHeaders

mcp = FastMCP("My Backend")

CROW_API_BASE = os.environ.get("API_BASE_URL", "https://api.usecrow.ai")
SERVICE_KEY = os.environ.get("SERVICE_KEY", "")

async def get_product_id(headers: dict = CurrentHeaders()) -> str:
    """Read product ID from header set by Crow."""
    value = headers.get("x-product-id", "")
    if not value:
        raise ValueError("Missing X-Product-ID header")
    return value

async def get_api_client(headers: dict = CurrentHeaders()) -> httpx.AsyncClient:
    """Create an authenticated HTTP client for Crow's API."""
    key = SERVICE_KEY or headers.get("x-service-key", "")
    return httpx.AsyncClient(
        base_url=CROW_API_BASE,
        headers={
            "Content-Type": "application/json",
            "X-Service-Key": key,
        },
        timeout=30.0,
    )

@mcp.tool()
async def get_order(
    order_id: str,
    product_id: str = Depends(get_product_id),
    client: httpx.AsyncClient = Depends(get_api_client),
) -> dict:
    """Look up an order. Calls back to Crow's API."""
    resp = await client.get(f"/api/products/{product_id}/orders/{order_id}")
    resp.raise_for_status()
    return resp.json()
```

```javascript Node.js
const CROW_API_BASE = process.env.API_BASE_URL || "https://api.usecrow.ai";
const SERVICE_KEY = process.env.SERVICE_KEY || "";

async function callCrowApi(path, headers) {
  const key = SERVICE_KEY || headers["x-service-key"] || "";
  const resp = await fetch(`${CROW_API_BASE}${path}`, {
    headers: {
      "Content-Type": "application/json",
      "X-Service-Key": key,
    },
  });
  if (!resp.ok) throw new Error(`Crow API error: ${resp.status}`);
  return resp.json();
}
```

</CodeGroup>

---

## Identity Headers

Identity headers let your MCP server know **who** the end user is. Crow extracts claims from the user's identity token and sends them as HTTP headers to your MCP server.

### How Identity Flows Through the Chain

```
1. Your backend mints an identity JWT:
   { "user_id": "user_456", "email": "alice@example.com", "tenant_id": "t_789" }

2. Widget sends it to Crow with every chat message

3. Crow decodes the JWT and has the claims available

4. For each header mapping you configured, Crow resolves the value:
   identity.user_id    → "user_456"
   identity.email      → "alice@example.com"
   identity.tenant_id  → "t_789"

5. Crow sends these as HTTP headers to your MCP server:
   X-User-ID: user_456
   X-Email: alice@example.com
   X-Tenant-ID: t_789
```

### Configuring Header Mappings

In the dashboard, under **Integration** → **Server-Side MCP** → **Header Mappings**, add mappings:

| Header Name | Source | What It Sends |
|-------------|--------|---------------|
| `X-User-ID` | `identity.user_id` | The logged-in user's ID |
| `X-Email` | `identity.email` | The user's email |
| `X-Tenant-ID` | `identity.tenant_id` | Custom claim from your JWT |
| `X-Product-ID` | `product.id` | The Crow product ID |

### Available Sources

**`identity.*`** — Any claim from the user's identity JWT:

| Source | Value |
|--------|-------|
| `identity.user_id` | User ID (from `user_id` claim) |
| `identity.email` | Email (from `email` claim) |
| `identity.name` | Name (from `name` claim) |
| `identity.<custom>` | Any custom claim you include when minting the JWT |

<Note>
Identity claims are only available for **authenticated** users. If the user hasn't been identified via [Identity Verification](/identity-verification), identity headers won't be sent.
</Note>

**`product.*`** — Fields from the Crow product configuration:

| Source | Value |
|--------|-------|
| `product.id` | The product ID |
| `product.name` | The product display name |
| `product.organization_id` | The org that owns this product |

### Reading Identity Headers in Your MCP Server

<CodeGroup>

```python Python (FastMCP)
from fastmcp.dependencies import Depends, CurrentHeaders

async def get_user_id(headers: dict = CurrentHeaders()) -> str:
    """Read user ID forwarded by Crow."""
    return headers.get("x-user-id", "")

@mcp.tool()
async def get_my_orders(
    user_id: str = Depends(get_user_id),
) -> dict:
    """Get orders for the current user."""
    if not user_id:
        return {"error": "User not authenticated"}
    return await db.orders.find_by_user(user_id)
```

```javascript Node.js
server.tool("get_my_orders", {}, async (args, { headers }) => {
  const userId = headers["x-user-id"];
  if (!userId) {
    return { content: [{ type: "text", text: "User not authenticated" }] };
  }
  const orders = await db.orders.findByUser(userId);
  return { content: [{ type: "text", text: JSON.stringify(orders) }] };
});
```

</CodeGroup>

---

## Putting It All Together

Here's a complete example: an MCP server that authenticates via service key, reads the user's identity, and serves user-specific data.

**Dashboard configuration:**

```
Server-Side MCP:
  Name: my-backend
  URL: https://mcp.yourapp.com/mcp
  Transport: Streamable HTTP

Header Mappings:
  X-User-ID    ← identity.user_id
  X-Product-ID ← product.id
```

**MCP server:**

```python
import os, hmac
import httpx
from fastmcp import FastMCP
from fastmcp.dependencies import Depends, CurrentHeaders

mcp = FastMCP("My Backend")
SERVICE_KEY = os.environ["SERVICE_KEY"]

async def verify_service_key(headers: dict = CurrentHeaders()):
    key = headers.get("x-service-key", "")
    if not hmac.compare_digest(key, SERVICE_KEY):
        raise ValueError("Unauthorized")

async def get_user_id(headers: dict = CurrentHeaders()) -> str:
    return headers.get("x-user-id", "")

@mcp.tool()
async def get_my_orders(
    _auth = Depends(verify_service_key),
    user_id: str = Depends(get_user_id),
) -> dict:
    """Get the current user's recent orders."""
    if not user_id:
        return {"error": "No authenticated user. Ask the user to log in."}
    orders = await db.orders.find_by_user(user_id, limit=10)
    return {"orders": orders}
```

**What happens when a user asks "show me my orders":**

```
1. Widget → Crow:     identity_token (JWT with user_id: "user_456")
2. Crow validates JWT, extracts user_id
3. Crow → MCP server: X-Service-Key: HCF8n..., X-User-ID: user_456
4. MCP server validates service key ✓
5. MCP server reads X-User-ID, queries database for user_456's orders
6. Returns orders → Crow → Widget → User sees their order list
```

---

## Edge Cases

| Scenario | What Happens |
|----------|-------------|
| **Anonymous user** (no identity token) | Identity headers are not sent. Your MCP server receives the service key but no user context. Tools still work, but can't do user-specific actions. |
| **Missing service key** on product | `X-Service-Key` header is not sent. Your MCP server can still be called, but can't authenticate the request or call back to Crow's API. |
| **Identity claim doesn't exist** | If a header mapping references a claim that isn't in the JWT (e.g., `identity.tenant_id` but tenant_id wasn't included), that header is simply not sent. No error. |
| **MCP server is down** | Crow surfaces an error to the user: "Could not connect to the MCP server." The agent continues without those tools. |

---

## Security Checklist

<Warning>
- **Never expose your service key client-side.** It's a server-to-server secret.
- **Always validate the service key** on your MCP server if it handles sensitive data.
- **Use constant-time comparison** for secret validation.
- **Set up Identity Verification** if your tools need to know who the user is.
- **Use HTTPS** in production for your MCP server URL.
</Warning>

## Troubleshooting

| Issue | Cause | Fix |
|-------|-------|-----|
| MCP server gets 401 calling Crow API | Service key mismatch | Ensure `SERVICE_KEY` env var on MCP server matches the product's service key in dashboard |
| Identity headers are empty | User not authenticated | Set up [Identity Verification](/identity-verification), ensure frontend calls `identify()` |
| `X-Service-Key` header missing | No service key set on product | Go to product **Settings**, set a service key |
| MCP server not receiving headers | Wrong transport | Use **Streamable HTTP** (not SSE) for header support |
| Custom claims not forwarded | Claim not in JWT | Ensure your backend includes the claim when minting the identity token |
